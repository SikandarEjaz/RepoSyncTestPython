name: Sync to Java Repo with Python-to-Java Translation

on:
  push:
    branches:
      - main
    paths:
      - 'sync_folder/**'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Python Repo
        uses: actions/checkout@v4
        with:
          path: python-repo

      - name: Checkout Java Repo
        uses: actions/checkout@v4
        with:
          repository: SikandarEjaz/RepoSyncTestJava
          token: ${{ secrets.SYNC_TOKEN }}
          path: java-repo

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Install ANTLR4
        run: |
          cd /usr/local/lib
          sudo curl -O https://www.antlr.org/download/antlr-4.13.1-complete.jar
          pip install antlr4-python3-runtime

      - name: Download Python Grammar
        run: |
          mkdir -p parser
          cd parser
          # Download Python3 grammar files - correct URLs
          curl -L -o Python3Lexer.g4 https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3Lexer.g4
          curl -L -o Python3Parser.g4 https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3Parser.g4
          
          # Verify files were downloaded correctly
          echo "=== Python3Lexer.g4 first line ==="
          head -n 1 Python3Lexer.g4
          echo "=== Python3Parser.g4 first line ==="
          head -n 1 Python3Parser.g4

      - name: Generate ANTLR Parser
        run: |
          cd parser
          java -jar /usr/local/lib/antlr-4.13.1-complete.jar -Dlanguage=Python3 Python3Lexer.g4 Python3Parser.g4

      - name: Create Python-to-Java Translator
        run: |
          cat > translator.py << 'TRANSLATOR_EOF'
          import sys
          import os
          from antlr4 import *
          from parser.Python3Lexer import Python3Lexer
          from parser.Python3Parser import Python3Parser
          from parser.Python3ParserListener import Python3ParserListener

          class PythonToJavaTranslator(Python3ParserListener):
              def __init__(self):
                  self.indent_level = 0
                  self.output = []
                  self.current_class = None
                  self.in_method = False
                  self.class_fields = set()
                  self.is_init_method = False
                  self.constructor_params = []
                  
              def get_indent(self):
                  return "    " * self.indent_level
              
              def enterClassdef(self, ctx):
                  # Get class name
                  class_name = ctx.NAME().getText()
                  self.current_class = class_name
                  
                  # Check for inheritance (arglist in Python3 grammar)
                  parent_class = ""
                  if ctx.arglist():
                      parent_names = []
                      for arg in ctx.arglist().argument():
                          parent_names.append(arg.getText())
                      if parent_names and parent_names[0] != "object":
                          parent_class = " extends " + parent_names[0]
                  
                  self.output.append(f"public class {class_name}{parent_class} {{")
                  self.indent_level += 1
                  
              def exitClassdef(self, ctx):
                  self.indent_level -= 1
                  self.output.append("}")
                  self.output.append("")
                  
              def enterFuncdef(self, ctx):
                  self.in_method = True
                  method_name = ctx.NAME().getText()
                  
                  # Get parameters
                  params = []
                  if ctx.parameters() and ctx.parameters().typedargslist():
                      typedargslist = ctx.parameters().typedargslist()
                      # Get all tfpdef (typed formal parameters)
                      for tfpdef in typedargslist.tfpdef():
                          param_name = tfpdef.NAME().getText()
                          params.append(param_name)
                  
                  # Remove 'self' from parameters
                  params = [p for p in params if p != "self"]
                  
                  # Check if it's __init__ (constructor)
                  if method_name == "__init__":
                      self.is_init_method = True
                      self.constructor_params = params
                      params_str = ", ".join([f"String {p}" for p in params])
                      
                      self.output.append(f"{self.get_indent()}public {self.current_class}({params_str}) {{")
                      self.indent_level += 1
                  else:
                      params_str = ", ".join([f"String {p}" for p in params])
                      
                      # Determine return type - check for return statement
                      return_type = "void"
                      if ctx.suite():
                          suite_text = ctx.suite().getText()
                          if "return" in suite_text:
                              return_type = "String"  # Default to String if returns something
                      
                      self.output.append(f"{self.get_indent()}public {return_type} {method_name}({params_str}) {{")
                      self.indent_level += 1
                  
              def exitFuncdef(self, ctx):
                  self.indent_level -= 1
                  self.output.append(f"{self.get_indent()}}}")
                  self.output.append("")
                  self.in_method = False
                  self.is_init_method = False
              
              def enterExpr_stmt(self, ctx):
                  if not self.in_method:
                      return
                      
                  # Get the statement text
                  stmt_text = ctx.getText()
                  
                  # Handle self.variable = value (field initialization)
                  if "self." in stmt_text and "=" in stmt_text:
                      # Parse assignment
                      if ctx.testlist_star_expr() and len(ctx.testlist_star_expr()) >= 1:
                          left_side = ctx.testlist_star_expr(0).getText()
                          
                          if "self." in left_side:
                              var_name = left_side.replace("self.", "").strip()
                              
                              # Get right side value
                              right_side = ""
                              if ctx.annassign():
                                  if ctx.annassign().test():
                                      right_side = ctx.annassign().test().getText()
                              elif ctx.augassign():
                                  right_side = ctx.testlist().getText() if ctx.testlist() else ""
                              elif len(ctx.testlist_star_expr()) >= 2:
                                  right_side = ctx.testlist_star_expr(1).getText()
                              elif ctx.yield_expr():
                                  right_side = ctx.yield_expr().getText()
                              
                              # Replace self. with parameter name if it matches
                              if right_side in self.constructor_params:
                                  # This is constructor parameter assignment
                                  self.class_fields.add(var_name)
                                  self.output.append(f"{self.get_indent()}this.{var_name} = {right_side};")
                              else:
                                  # Regular assignment
                                  right_side = right_side.replace("self.", "this.")
                                  self.output.append(f"{self.get_indent()}this.{var_name} = {right_side};")
                  elif "=" in stmt_text and "self." not in stmt_text:
                      # Regular variable assignment
                      stmt_text = stmt_text.replace("self.", "this.")
                      if not stmt_text.endswith(";"):
                          stmt_text += ";"
                      self.output.append(f"{self.get_indent()}{stmt_text}")
              
              def enterReturn_stmt(self, ctx):
                  if self.in_method:
                      return_value = ""
                      if ctx.testlist():
                          return_value = ctx.testlist().getText()
                          # Replace self. with this.
                          return_value = return_value.replace("self.", "this.")
                      
                      if return_value:
                          self.output.append(f"{self.get_indent()}return {return_value};")
                      else:
                          self.output.append(f"{self.get_indent()}return;")
              
              def enterAtom_expr(self, ctx):
                  if not self.in_method:
                      return
                      
                  expr_text = ctx.getText()
                  
                  # Handle print() calls
                  if expr_text.startswith("print("):
                      # Extract arguments
                      if ctx.trailer():
                          for trailer in ctx.trailer():
                              if trailer.arglist():
                                  args = trailer.arglist().getText()
                                  # Convert print arguments
                                  java_args = self.convert_print_args(args)
                                  self.output.append(f"{self.get_indent()}System.out.println({java_args});")
              
              def convert_print_args(self, args):
                  # Replace self. with this.
                  args = args.replace("self.", "this.")
                  
                  # Handle f-strings (basic)
                  if args.startswith('f"') or args.startswith("f'"):
                      args = args[2:-1]  # Remove f" and "
                      # Simple replacement of {var} with " + var + "
                      import re
                      args = re.sub(r'\{([^}]+)\}', r'" + \1 + "', args)
                      args = '"' + args + '"'
                      # Clean up
                      args = args.replace('"" + ', '').replace(' + ""', '')
                  
                  return args
              
              def get_java_code(self):
                  # Add field declarations at the beginning of the class
                  if self.class_fields:
                      lines = self.output[:]
                      # Find where to insert fields (after class declaration)
                      for i, line in enumerate(lines):
                          if "public class" in line:
                              insert_pos = i + 1
                              # Insert fields
                              for field in sorted(self.class_fields):
                                  lines.insert(insert_pos, f"    private String {field};")
                                  insert_pos += 1
                              # Add blank line after fields
                              lines.insert(insert_pos, "")
                              break
                      self.output = lines
                  
                  return "\n".join(self.output)

          def translate_python_to_java(python_file_path):
              with open(python_file_path, 'r', encoding='utf-8') as f:
                  python_code = f.read()
              
              input_stream = InputStream(python_code)
              lexer = Python3Lexer(input_stream)
              token_stream = CommonTokenStream(lexer)
              parser = Python3Parser(token_stream)
              tree = parser.file_input()
              
              translator = PythonToJavaTranslator()
              walker = ParseTreeWalker()
              walker.walk(translator, tree)
              
              return translator.get_java_code()

          if __name__ == "__main__":
              if len(sys.argv) != 3:
                  print("Usage: python translator.py <input_python_file> <output_java_file>")
                  sys.exit(1)
              
              input_file = sys.argv[1]
              output_file = sys.argv[2]
              
              try:
                  java_code = translate_python_to_java(input_file)
                  
                  with open(output_file, 'w', encoding='utf-8') as f:
                      f.write(java_code)
                  
                  print(f"Translated {input_file} to {output_file}")
              except Exception as e:
                  print(f"Translation error: {e}")
                  import traceback
                  traceback.print_exc()
          TRANSLATOR_EOF

      - name: Translate Python files to Java
        run: |
          mkdir -p java-repo/synced-from-python
          
          # Find all Python files in sync_folder
          find python-repo/sync_folder -name "*.py" -type f | while read python_file; do
            # Skip __pycache__ and test files
            if [[ "$python_file" == *"__pycache__"* ]] || [[ "$python_file" == *"__init__.py" ]]; then
              continue
            fi
            
            # Get relative path and convert to Java filename
            rel_path=$(realpath --relative-to=python-repo/sync_folder "$python_file")
            java_file="java-repo/synced-from-python/${rel_path%.py}.java"
            
            # Create directory if needed
            mkdir -p "$(dirname "$java_file")"
            
            # Translate
            echo "Translating: $python_file -> $java_file"
            python translator.py "$python_file" "$java_file" || echo "Translation failed for $python_file"
          done
          
          # Also copy non-Python files
          find python-repo/sync_folder -type f ! -name "*.py" ! -name "__pycache__" | while read file; do
            rel_path=$(realpath --relative-to=python-repo/sync_folder "$file")
            mkdir -p "$(dirname "java-repo/synced-from-python/$rel_path")"
            cp "$file" "java-repo/synced-from-python/$rel_path"
          done

      - name: Commit and Push to Java Repo
        run: |
          cd java-repo
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add .
          git diff --quiet && git diff --staged --quiet || git commit -m "Sync from Python repo with translation [automated]"
          git push