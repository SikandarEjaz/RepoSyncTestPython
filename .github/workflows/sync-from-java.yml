name: Sync to Java Repo with Python-to-Java Translation

on:
  push:
    branches:
      - main
    paths:
      - 'sync_folder/**'
  workflow_dispatch:

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Python Repo
        uses: actions/checkout@v4
        with:
          path: python-repo

      - name: Checkout Java Repo
        uses: actions/checkout@v4
        with:
          repository: SikandarEjaz/RepoSyncTestJava
          token: ${{ secrets.SYNC_TOKEN }}
          path: java-repo

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Install ANTLR4
        run: |
          cd /usr/local/lib
          sudo curl -O https://www.antlr.org/download/antlr-4.13.1-complete.jar
          pip install antlr4-python3-runtime

      - name: Download Python Grammar and Base Files
        run: |
          mkdir -p parser
          cd parser
          # Download Python3 grammar files
          curl -L -o Python3Lexer.g4 https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3Lexer.g4
          curl -L -o Python3Parser.g4 https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3Parser.g4
          
          # Download the base files needed by the lexer
          curl -L -o Python3LexerBase.py https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3LexerBase.py
          curl -L -o Python3ParserBase.py https://raw.githubusercontent.com/antlr/grammars-v4/master/python/python3/Python3ParserBase.py
          
          # Create __init__.py to make it a proper package
          touch __init__.py
          
          # Verify files were downloaded correctly
          echo "=== Downloaded files ==="
          ls -la
          echo "=== Python3Lexer.g4 first line ==="
          head -n 1 Python3Lexer.g4
          echo "=== Python3Parser.g4 first line ==="
          head -n 1 Python3Parser.g4

      - name: Generate ANTLR Parser
        run: |
          cd parser
          java -jar /usr/local/lib/antlr-4.13.1-complete.jar -Dlanguage=Python3 Python3Lexer.g4 Python3Parser.g4
          
          # Verify generated files
          echo "=== Generated Python files ==="
          ls -la *.py

      - name: Create Python-to-Java Translator
        run: |
          cat > translator.py << 'TRANSLATOR_EOF'
          import sys
          import os
          from antlr4 import *
          from parser.Python3Lexer import Python3Lexer
          from parser.Python3Parser import Python3Parser
          from parser.Python3ParserListener import Python3ParserListener

          class PythonToJavaTranslator(Python3ParserListener):
              def __init__(self):
                  self.indent_level = 0
                  self.output = []
                  self.current_class = None
                  self.in_method = False
                  self.class_fields = set()
                  self.is_init_method = False
                  self.constructor_params = []
                  self.in_if_statement = False
                  
              def get_indent(self):
                  return "    " * self.indent_level
              
              def enterClassdef(self, ctx):
                  # Get class name
                  class_name = ctx.NAME().getText()
                  self.current_class = class_name
                  
                  # Check for inheritance
                  parent_class = ""
                  if ctx.arglist():
                      parent_names = []
                      for arg in ctx.arglist().argument():
                          parent_names.append(arg.getText())
                      if parent_names and parent_names[0] != "object":
                          parent_class = " extends " + parent_names[0]
                  
                  self.output.append(f"public class {class_name}{parent_class} {{")
                  self.indent_level += 1
                  
              def exitClassdef(self, ctx):
                  self.indent_level -= 1
                  self.output.append("}")
                  self.output.append("")
                  
              def enterFuncdef(self, ctx):
                  self.in_method = True
                  method_name = ctx.NAME().getText()
                  
                  # Get parameters
                  params = []
                  if ctx.parameters() and ctx.parameters().typedargslist():
                      typedargslist = ctx.parameters().typedargslist()
                      for tfpdef in typedargslist.tfpdef():
                          param_name = tfpdef.NAME().getText()
                          params.append(param_name)
                  
                  # Remove 'self' from parameters
                  params = [p for p in params if p != "self"]
                  
                  # Check if it's __init__ (constructor)
                  if method_name == "__init__":
                      self.is_init_method = True
                      self.constructor_params = params
                      params_str = ", ".join([f"String {p}" for p in params])
                      
                      self.output.append(f"{self.get_indent()}public {self.current_class}({params_str}) {{")
                      self.indent_level += 1
                  else:
                      params_str = ", ".join([f"String {p}" for p in params])
                      
                      # Determine return type
                      return_type = "void"
                      if ctx.suite():
                          suite_text = ctx.suite().getText()
                          if "returnTrue" in suite_text or "returnFalse" in suite_text:
                              return_type = "boolean"
                          elif "return" in suite_text and "returnNone" not in suite_text:
                              return_type = "String"
                      
                      self.output.append(f"{self.get_indent()}public {return_type} {method_name}({params_str}) {{")
                      self.indent_level += 1
                  
              def exitFuncdef(self, ctx):
                  self.indent_level -= 1
                  self.output.append(f"{self.get_indent()}}}")
                  self.output.append("")
                  self.in_method = False
                  self.is_init_method = False
              
              def enterExpr_stmt(self, ctx):
                  if not self.in_method or self.in_if_statement:
                      return
                      
                  stmt_text = ctx.getText()
                  
                  # Handle self.variable = value
                  if "self." in stmt_text and "=" in stmt_text:
                      parts = stmt_text.split("=", 1)
                      if len(parts) == 2:
                          left = parts[0].strip()
                          right = parts[1].strip()
                          
                          if left.startswith("self."):
                              var_name = left.replace("self.", "")
                              self.class_fields.add(var_name)
                              
                              # Check if right side is a parameter
                              if right in self.constructor_params:
                                  self.output.append(f"{self.get_indent()}this.{var_name} = {right};")
                              else:
                                  right = right.replace("self.", "this.")
                                  self.output.append(f"{self.get_indent()}this.{var_name} = {right};")
              
              def enterIf_stmt(self, ctx):
                  if not self.in_method:
                      return
                  
                  self.in_if_statement = True
                  # Get condition
                  condition = ctx.test(0).getText()
                  condition = condition.replace("self.", "this.")
                  condition = condition.replace(">=", ">=").replace("<=", "<=")
                  
                  self.output.append(f"{self.get_indent()}if ({condition}) {{")
                  self.indent_level += 1
              
              def exitIf_stmt(self, ctx):
                  if not self.in_method:
                      return
                      
                  self.indent_level -= 1
                  self.output.append(f"{self.get_indent()}}}")
                  self.in_if_statement = False
              
              def enterReturn_stmt(self, ctx):
                  if self.in_method:
                      return_value = ""
                      if ctx.testlist():
                          return_value = ctx.testlist().getText()
                          # Replace self. with this.
                          return_value = return_value.replace("self.", "this.")
                          # Handle boolean values
                          if return_value == "True":
                              return_value = "true"
                          elif return_value == "False":
                              return_value = "false"
                      
                      if return_value:
                          self.output.append(f"{self.get_indent()}return {return_value};")
                      else:
                          self.output.append(f"{self.get_indent()}return;")
              
              def enterAtom_expr(self, ctx):
                  if not self.in_method or self.in_if_statement:
                      return
                      
                  expr_text = ctx.getText()
                  
                  # Handle print() calls
                  if expr_text.startswith("print("):
                      if ctx.trailer():
                          for trailer in ctx.trailer():
                              if trailer.arglist():
                                  args = trailer.arglist().getText()
                                  java_args = self.convert_print_args(args)
                                  self.output.append(f"{self.get_indent()}System.out.println({java_args});")
              
              def convert_print_args(self, args):
                  # Replace self. with this.
                  args = args.replace("self.", "this.")
                  
                  # Handle f-strings
                  if args.startswith('f"') or args.startswith("f'"):
                      quote = args[1]
                      args = args[2:-1]  # Remove f" and "
                      
                      # Replace {var} with " + var + "
                      import re
                      args = re.sub(r'\{([^}]+)\}', r'" + \1 + "', args)
                      args = '"' + args + '"'
                      # Clean up
                      args = args.replace('"" + ', '').replace(' + ""', '')
                      args = args.replace('+ " " +', '+ " " +')  # Keep spaces
                  
                  return args
              
              def get_java_code(self):
                  # Add field declarations
                  if self.class_fields:
                      lines = self.output[:]
                      for i, line in enumerate(lines):
                          if "public class" in line:
                              insert_pos = i + 1
                              for field in sorted(self.class_fields):
                                  lines.insert(insert_pos, f"    private String {field};")
                                  insert_pos += 1
                              lines.insert(insert_pos, "")
                              break
                      self.output = lines
                  
                  return "\n".join(self.output)

          def translate_python_to_java(python_file_path):
              with open(python_file_path, 'r', encoding='utf-8') as f:
                  python_code = f.read()
              
              input_stream = InputStream(python_code)
              lexer = Python3Lexer(input_stream)
              token_stream = CommonTokenStream(lexer)
              parser = Python3Parser(token_stream)
              tree = parser.file_input()
              
              translator = PythonToJavaTranslator()
              walker = ParseTreeWalker()
              walker.walk(translator, tree)
              
              return translator.get_java_code()

          if __name__ == "__main__":
              if len(sys.argv) != 3:
                  print("Usage: python translator.py <input_python_file> <output_java_file>")
                  sys.exit(1)
              
              input_file = sys.argv[1]
              output_file = sys.argv[2]
              
              try:
                  java_code = translate_python_to_java(input_file)
                  
                  with open(output_file, 'w', encoding='utf-8') as f:
                      f.write(java_code)
                  
                  print(f"Successfully translated {input_file} to {output_file}")
                  print(f"Generated Java code preview:")
                  print(java_code[:500])
              except Exception as e:
                  print(f"Translation error: {e}")
                  import traceback
                  traceback.print_exc()
                  sys.exit(1)
          TRANSLATOR_EOF

      - name: Translate Python files to Java
        run: |
          mkdir -p java-repo/synced-from-python
          
          # Find all Python files in sync_folder
          find python-repo/sync_folder -name "*.py" -type f | while read python_file; do
            # Skip __pycache__ and __init__ files
            if [[ "$python_file" == *"__pycache__"* ]] || [[ "$python_file" == *"__init__.py" ]]; then
              echo "Skipping: $python_file"
              continue
            fi
            
            # Get relative path and convert to Java filename
            rel_path=$(realpath --relative-to=python-repo/sync_folder "$python_file")
            java_file="java-repo/synced-from-python/${rel_path%.py}.java"
            
            # Create directory if needed
            mkdir -p "$(dirname "$java_file")"
            
            # Translate
            echo "Translating: $python_file -> $java_file"
            if python translator.py "$python_file" "$java_file"; then
              echo "✓ Translation successful"
              ls -la "$java_file"
            else
              echo "✗ Translation failed for $python_file"
            fi
          done
          
          # Show what was created
          echo "=== Files in synced-from-python ==="
          ls -laR java-repo/synced-from-python/ || echo "No files created"

      - name: Commit and Push to Java Repo
        run: |
          cd java-repo
          git config user.name "GitHub Action"
          git config user.email "action@github.com"
          git add .
          
          # Check if there are changes
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "Sync from Python repo with translation [automated]"
            git push
            echo "✓ Changes pushed successfully"
          fi